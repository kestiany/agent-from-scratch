# Week 06 · Design Review

> 主题：**让 Agent 知道自己在干嘛**
>
> 关键词：Planning · Trace · 可中断 · 可继续

---

## 一、本周目标回顾

在整体 12 周蓝图中，第 06 周处于一个**非常关键的拐点**：

- 前 1–4 周解决的是：**Agent 能不能稳定跑**
- 第 05 周引入角色，解决：**任务拆解是否可解释**
- **第 06 周要解决的问题是：**

> 👉 Agent 在执行过程中，**是否对“自己正在做什么”有显式认知？**

因此，本周的设计目标不是“更聪明”，而是：

- 执行过程可追踪
- 中间结果可检查
- 执行流可被中断 / 继续

---

## 二、核心设计目标（Design Goals）

### 🎯 目标 1：任务必须先被 Plan

- 任何用户输入都不能直接进入执行
- Planner 必须先产出 `TaskPlan`
- 执行阶段只能消费 Plan，而不能“自由发挥”

> 这是从 Prompt 驱动 → 系统驱动 的关键一步。

---

### 🎯 目标 2：执行过程显式化（Execution is State Transition）

- 每个 SubTask 都有明确状态：
  - PENDING
  - IN_PROGRESS
  - COMPLETED
  - FAILED
- 状态变化是系统唯一事实来源

执行 ≠ LLM 调用

执行 = **状态从 A → B 的转移**

---

### 🎯 目标 3：Review 成为一等公民

- 每个子任务都必须经过 Reviewer
- Review 不是布尔值，而是结构化结果
- Review 决定：
  - 是否进入下一个任务
  - 是否触发反思 / 重试

> 没有 Review，就没有真正的 Agent。

---

### 🎯 目标 4：每一次 Run 都可追踪

- 每次执行都有唯一 Run 语义
- 所有关键节点都被记录为事件

这为后续的：
- Debug
- Replay
- Resume

奠定基础。

---

## 三、关键架构设计

### 1️⃣ TaskPlan / SubTask Schema

**设计动机：**

- 把“任务”从自然语言，提升为系统级对象
- 避免执行阶段再做隐式决策

**核心特征：**

- Planner 只负责生成 Plan
- Executor 严格按 Plan 执行
- Kernel 不关心具体任务语义

---

### 2️⃣ Agent Kernel（执行内核）

Kernel 的职责被严格限制为：

- 驱动 Plan → Execute → Review 循环
- 控制状态流转
- 处理失败与重试路径

Kernel **不做的事**：

- 不理解业务
- 不拆任务
- 不写 Prompt

这是系统长期稳定性的核心。

---

### 3️⃣ ExecutionTracer（执行轨迹）

本周新增的关键基础设施。

记录内容包括：

- Run 生命周期（start / finish）
- Task 执行开始 / 结束
- Review 结果

设计取向：

- 事件驱动
- 与具体 Agent 解耦
- 为后续可观测性服务

---

## 四、关键取舍与边界说明

### ❌ 为什么没有引入 LangGraph？

- 当前阶段关注的是：**控制权与可解释性**
- DAG 框架会过早引入抽象负担

本阶段选择：

> 用最小控制流，换最大理解深度

---

### ❌ 为什么 Review 不直接写在 Executor 里？

- 执行 ≠ 评判
- Reviewer 是独立认知角色

这为后续：
- 多 Reviewer
- 自动对比

保留空间。

---

## 五、本周达成状态总结

到 Week 06 结束，系统已经具备：

- ✅ 明确的任务 Plan
- ✅ 可追踪的执行流
- ✅ 强制 Review 闭环
- ✅ 清晰的 Kernel 边界

系统已从：

> "能跑的 Agent"

演进为：

> **"知道自己在做什么的 Agent 系统"**

---

## 六、为下一阶段预留的接口

本周设计刻意留下了以下扩展点：

- 基于 Trace 的中断 / 恢复
- Memory Layer（短期 / 长期）
- 成本与性能观测

这些都不需要推翻现有结构。

---

## 七、一句话总结

> **Week 06 不是增加能力，而是确立秩序。**
>
> 当 Agent 的执行不再是黑盒，
> 后续的一切智能，才有意义。

